<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Gravity Notes</title>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            font-family: sans-serif;
        }

        #block-container {
            height: 100vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .markdown-block {
            border-bottom: 1px solid #ccc;
            padding: 0.5rem;
            position: relative; /* Needed for absolute positioning of buttons */
            min-height: 3rem;
            box-sizing: border-box; /* Include padding in height calculation */
        }

        .markdown-content {
            cursor: pointer;
            white-space: pre-wrap;
            word-break: break-word;
            margin: 0;
            /* Use padding shorthand (top, right, bottom, left) */
            padding: 0 6rem 0 0;
            min-height: 1.5rem; /* Ensure content takes up space for clicking */
        }

        /* Style for the note currently being edited */
        .editing-in-place .markdown-content {
            display: none;
        }

        .editing-in-place .markdown-editor {
            display: block;
        }

        /* Style specifically for the TOP/ACTIVE note's editor */
        .edit-mode .markdown-content {
            display: none;
        }

        .edit-mode .markdown-editor {
            display: block;
        }


        .markdown-editor {
            display: none; /* Hide editors by default */
            width: 100%;
            border: none;
            outline: none;
            font-family: inherit;
            font-size: 1rem;
            background: transparent;
            resize: none;
            white-space: pre-wrap;
            word-break: break-word;
            overflow: hidden;
            /* Use padding shorthand (top, right, bottom, left) */
            padding: 0 6rem 0 0;
            box-sizing: border-box; /* Ensure padding is included in width */
        }


        .arrow-btn,
        .merge-btn-up,
        .merge-btn-down {
            position: absolute;
            background: transparent;
            border: none;
            cursor: pointer;
            user-select: none;
            font-size: 0.9rem;
            color: #007bff;
            padding: 0.2rem 0.3rem; /* Make buttons slightly larger */
            line-height: 1; /* Ensure consistent vertical alignment */
        }

        .arrow-btn:hover,
        .merge-btn-up:hover,
        .merge-btn-down:hover {
            color: #0056b3;
        }

        .arrow-up {
            top: 0.5rem;
            right: 1rem; /* Align vertically with down arrow */
        }

        .arrow-down {
            bottom: 0.5rem;
            right: 1rem;
        }

        .merge-btn-up {
            top: 0.5rem;
            right: 4rem; /* Keep merge buttons separate */
            color: #28a745;
        }

        .merge-btn-up:hover {
            color: #1e7e34;
        }

        .merge-btn-down {
            top: 0.5rem;
            right: 4rem; /* Align with merge up button */
            color: #28a745;
        }

        .merge-btn-down:hover {
            color: #1e7e34;
        }
    </style>
</head>
<body>
<div id="block-container"></div>
<script>
    marked.setOptions({gfm: true, breaks: true});

    let currentlyEditingNoteElement = null; // Track which note is being edited
    let isPerformingMerge = false; // Flag for merge operations

    const blockContainer = document.getElementById("block-container");

    /**
     * Ensures the top note is the active editor.
     */
    function setActiveTopNote(noteElement) {
        if (currentlyEditingNoteElement && currentlyEditingNoteElement !== noteElement) {
            if (!isPerformingMerge) {
                finalizeNoteEditing(currentlyEditingNoteElement);
            }
        }
        currentlyEditingNoteElement = noteElement;

        Array.from(blockContainer.children).forEach(eachNote => {
            eachNote.classList.remove('editing-in-place');
            if (eachNote !== noteElement) {
                eachNote.classList.remove('edit-mode');
            }
        });

        noteElement.classList.add('edit-mode');
        const noteEditorElement = noteElement.querySelector(".markdown-editor");
        autoResize(noteEditorElement);
        setTimeout(() => noteEditorElement?.focus(), 0);
        updateActionButtons();
    }

    /**
     * Enables editing for a non-top note IN PLACE.
     */
    function enableNoteEditing(noteElement) {
        if (noteElement === currentlyEditingNoteElement) return;

        if (currentlyEditingNoteElement) {
            if (!isPerformingMerge) {
                finalizeNoteEditing(currentlyEditingNoteElement);
            }
        }

        const topNote = blockContainer.firstElementChild;
        if (topNote) topNote.classList.remove('edit-mode');

        Array.from(blockContainer.children).forEach(eachNote => {
            if (eachNote !== noteElement) {
                eachNote.classList.remove('editing-in-place');
            }
        });

        currentlyEditingNoteElement = noteElement;
        noteElement.classList.add('editing-in-place');

        const noteEditorElement = noteElement.querySelector(".markdown-editor");
        autoResize(noteEditorElement);
        setTimeout(() => noteEditorElement?.focus(), 0);
        updateActionButtons();
    }


    /**
     * Finalizes editing on a note. Removed unused blurEvent parameter.
     */
    function finalizeNoteEditing(noteElement) { // Removed blurEvent parameter
        if (!noteElement || noteElement !== currentlyEditingNoteElement || isPerformingMerge) {
            return;
        }

        const isTopActiveEditing = noteElement.classList.contains('edit-mode');
        const isInPlaceEditing = noteElement.classList.contains('editing-in-place');
        if (!isTopActiveEditing && !isInPlaceEditing) {
            return;
        }

        const noteEditorElement = noteElement.querySelector(".markdown-editor");
        const notePreviewElement = noteElement.querySelector(".markdown-content");

        if (!noteEditorElement || !notePreviewElement) {
            console.error("Finalize: Missing editor or preview element for note.", noteElement);
            noteElement.classList.remove('edit-mode');
            noteElement.classList.remove('editing-in-place');
            if (currentlyEditingNoteElement === noteElement) {
                currentlyEditingNoteElement = null;
            }
            updateActionButtons();
            return;
        }

        const noteTextContent = noteEditorElement.value;
        notePreviewElement.innerHTML = marked.parse(noteTextContent);

        const wasTopNote = (noteElement === blockContainer.firstElementChild && isTopActiveEditing);

        noteElement.classList.remove('edit-mode');
        noteElement.classList.remove('editing-in-place');
        currentlyEditingNoteElement = null;

        if (wasTopNote) {
            const isNoteNonEmpty = noteTextContent.trim() !== "";
            if (isNoteNonEmpty) {
                const newActiveNoteElement = createNote("");
                blockContainer.prepend(newActiveNoteElement);
                setActiveTopNote(newActiveNoteElement);
            } else {
                setActiveTopNote(noteElement);
            }
        } else {
            updateActionButtons();
        }
    }


    /**
     * Automatically resizes a textarea to its content height.
     */
    function autoResize(textareaElement) {
        if (!textareaElement) return;
        textareaElement.style.height = "auto";
        const bufferHeight = 5;
        textareaElement.style.height = (textareaElement.scrollHeight + bufferHeight) + "px";
    }


    /**
     * Creates a button element.
     */
    function createIconButton(iconLabelText, cssClassForButton, clickHandlerFunction) {
        const buttonElement = document.createElement("button");
        buttonElement.className = cssClassForButton;
        buttonElement.textContent = iconLabelText;
        buttonElement.setAttribute("aria-label", iconLabelText.replace("↑", "up").replace("↓", "down"));

        if (cssClassForButton.includes("merge-btn")) {
            buttonElement.addEventListener("mousedown", function (mouseDownEvent) {
                mouseDownEvent.preventDefault();
                isPerformingMerge = true;
                try {
                    clickHandlerFunction();
                } finally {
                    setTimeout(() => { isPerformingMerge = false; }, 50);
                }
            });
        } else { // Arrow buttons
            buttonElement.addEventListener("click", function (clickEvent) {
                clickEvent.stopPropagation();
                clickHandlerFunction();
            });
        }
        return buttonElement;
    }


    /**
     * Creates and returns a new note element.
     */
    function createNote(initialNoteText) {
        const noteElement = document.createElement("div");
        noteElement.className = "markdown-block";
        const notePreviewElement = document.createElement("p");
        notePreviewElement.className = "markdown-content";
        notePreviewElement.innerHTML = marked.parse(initialNoteText);
        const noteEditorElement = document.createElement("textarea");
        noteEditorElement.className = "markdown-editor";
        noteEditorElement.value = initialNoteText;
        noteEditorElement.setAttribute("rows", "1");

        noteEditorElement.addEventListener("input", function () {
            autoResize(noteEditorElement);
            notePreviewElement.innerHTML = marked.parse(noteEditorElement.value);
        });
        noteEditorElement.addEventListener("keydown", function (keyEvent) {
            if (keyEvent.key === "Enter" && !keyEvent.shiftKey) {
                keyEvent.preventDefault();
                isPerformingMerge = false;
                finalizeNoteEditing(noteElement);
            }
        });
        noteEditorElement.addEventListener("blur", function () { // Removed unused blurEvent parameter
            if (!isPerformingMerge) {
                finalizeNoteEditing(noteElement); // Call without event object
            }
        });

        notePreviewElement.addEventListener("mousedown", function () { // Removed unused mouseDownEvent parameter
            if (noteElement === blockContainer.firstElementChild) {
                setActiveTopNote(noteElement);
            } else {
                enableNoteEditing(noteElement);
            }
        });

        noteEditorElement.addEventListener("paste", function (pasteEvent) {
            handleImagePaste(pasteEvent, noteEditorElement, notePreviewElement);
        });

        // Create buttons
        const upArrowButton = createIconButton("▲", "arrow-btn arrow-up", function () { moveNote(noteElement, -1); });
        const downArrowButton = createIconButton("▼", "arrow-btn arrow-down", function () { moveNote(noteElement, 1); });
        const mergeUpButton = createIconButton("Merge ↑", "merge-btn-up", function () { mergeNoteUp(noteElement); });
        const mergeDownButton = createIconButton("Merge ↓", "merge-btn-down", function () { mergeNoteDown(noteElement); });

        // Append elements
        noteElement.appendChild(mergeUpButton);
        noteElement.appendChild(mergeDownButton);
        noteElement.appendChild(upArrowButton);
        noteElement.appendChild(downArrowButton);
        noteElement.appendChild(notePreviewElement);
        noteElement.appendChild(noteEditorElement);
        autoResize(noteEditorElement);
        return noteElement;
    }

    /**
     * Updates visibility of action buttons.
     */
    function updateActionButtons() {
        const noteElementsArray = Array.from(blockContainer.children);
        const totalNotesCount = noteElementsArray.length;

        noteElementsArray.forEach(function (currentNoteElement, noteIndex) {
            const mergeUpButtonElement = currentNoteElement.querySelector(".merge-btn-up");
            const mergeDownButtonElement = currentNoteElement.querySelector(".merge-btn-down");
            const upArrowButtonElement = currentNoteElement.querySelector(".arrow-up");
            const downArrowButtonElement = currentNoteElement.querySelector(".arrow-down");

            const setDisplay = (element, displayValue) => {
                if (element) element.style.display = displayValue;
            };

            if (noteIndex === 0) { // Top note
                setDisplay(mergeUpButtonElement, "none");
                setDisplay(mergeDownButtonElement, "none");
                setDisplay(upArrowButtonElement, "none");
                setDisplay(downArrowButtonElement, "none");
            } else { // Non-top notes
                const isSecondNote = (noteIndex === 1);
                const isLastNote = (noteIndex === totalNotesCount - 1);

                setDisplay(upArrowButtonElement, !isSecondNote ? "block" : "none");
                setDisplay(downArrowButtonElement, !isLastNote ? "block" : "none");

                if (totalNotesCount > 1) {
                    if (isLastNote) {
                        setDisplay(mergeUpButtonElement, "block");
                        setDisplay(mergeDownButtonElement, "none");
                    } else {
                        setDisplay(mergeUpButtonElement, "none");
                        setDisplay(mergeDownButtonElement, "block");
                    }
                } else {
                    setDisplay(mergeUpButtonElement, "none");
                    setDisplay(mergeDownButtonElement, "none");
                }
            }
        });
    }


    /**
     * Moves a non-top note up or down.
     */
    function moveNote(noteElement, movementDirection) {
        if (noteElement === blockContainer.firstElementChild) return;

        const noteElementsArray = Array.from(blockContainer.children);
        const currentNoteIndex = noteElementsArray.indexOf(noteElement);
        const targetIndex = currentNoteIndex + movementDirection;

        if (targetIndex <= 0 || targetIndex >= noteElementsArray.length) return;

        const referenceNoteElement = noteElementsArray[targetIndex];

        if (movementDirection === -1) {
            blockContainer.insertBefore(noteElement, referenceNoteElement);
        } else {
            blockContainer.insertBefore(noteElement, referenceNoteElement.nextSibling);
        }
        updateActionButtons();
    }


    /**
     * Merges a non-top note into the note immediately below it.
     */
    function mergeNoteDown(noteElementToMerge) {
        if (noteElementToMerge === blockContainer.firstElementChild) return;
        const noteBelowElement = noteElementToMerge.nextElementSibling;
        if (!noteBelowElement) return;

        const currentNoteEditorElement = noteElementToMerge.querySelector(".markdown-editor");
        const belowNoteEditorElement = noteBelowElement.querySelector(".markdown-editor");

        if (!currentNoteEditorElement || !belowNoteEditorElement) {
            console.error("Merge Down Error: Could not find editor elements.");
            return;
        }

        const currentNoteText = currentNoteEditorElement.value.trim();
        const belowNoteText = belowNoteEditorElement.value.trim();
        const separator = (currentNoteText && belowNoteText) ? "\n\n" : "";
        const mergedNoteText = currentNoteText + separator + belowNoteText;

        belowNoteEditorElement.value = mergedNoteText;

        const belowNoteContentElement = noteBelowElement.querySelector(".markdown-content");
        if (belowNoteContentElement) {
            belowNoteContentElement.innerHTML = marked.parse(mergedNoteText);
        } else {
            console.error("Merge Down Error: Could not find content element in target note.");
        }

        autoResize(belowNoteEditorElement);

        if (noteElementToMerge === currentlyEditingNoteElement) {
            currentlyEditingNoteElement = null;
        }

        noteElementToMerge.remove();
        updateActionButtons();
    }

    /**
     * Merges the bottom-most non-top note into the note immediately PRECEDING it.
     */
    function mergeNoteUp(bottomNoteElement) {
        if (bottomNoteElement !== blockContainer.lastElementChild || blockContainer.children.length < 2) return;
        const precedingNoteElement = bottomNoteElement.previousElementSibling;
        if (!precedingNoteElement || precedingNoteElement === blockContainer.firstElementChild) return;

        const precedingNoteEditorElement = precedingNoteElement.querySelector(".markdown-editor");
        const bottomNoteEditorElement = bottomNoteElement.querySelector(".markdown-editor");

        if (!precedingNoteEditorElement || !bottomNoteEditorElement) {
            console.error("Merge Up Error: Could not find editor elements.");
            return;
        }

        const precedingNoteText = precedingNoteEditorElement.value.trim();
        const bottomNoteText = bottomNoteEditorElement.value.trim();
        const separator = (precedingNoteText && bottomNoteText) ? "\n\n" : "";
        const mergedNoteText = precedingNoteText + separator + bottomNoteText;

        precedingNoteEditorElement.value = mergedNoteText;

        const precedingNoteContentElement = precedingNoteElement.querySelector(".markdown-content");
        if (precedingNoteContentElement) {
            precedingNoteContentElement.innerHTML = marked.parse(mergedNoteText);
        } else {
            console.error("Merge Up Error: Could not find content element in target note.");
        }

        autoResize(precedingNoteEditorElement);

        if (bottomNoteElement === currentlyEditingNoteElement) {
            currentlyEditingNoteElement = null;
        }

        bottomNoteElement.remove();
        updateActionButtons();
    }


    /**
     * Converts a pasted image to a base64 URL and inserts it as Markdown.
     */
    function handleImagePaste(pasteEvent, noteEditorElement, notePreviewElement) {
        if (!noteEditorElement || !notePreviewElement) return;

        if (pasteEvent.clipboardData && pasteEvent.clipboardData.files && pasteEvent.clipboardData.files.length > 0) {
            const pastedFile = pasteEvent.clipboardData.files[0];
            if (pastedFile.type.startsWith("image/")) {
                pasteEvent.preventDefault();
                const fileReaderObject = new FileReader();
                const insertionCursorPosition = noteEditorElement.selectionStart;

                fileReaderObject.onload = function (loadEventObject) {
                    if (!loadEventObject.target || !loadEventObject.target.result) return;

                    const imageMarkdownText = "\n\n![pasted image](" + loadEventObject.target.result + ")\n\n";
                    const currentText = noteEditorElement.value;
                    const textBeforeCursor = currentText.substring(0, insertionCursorPosition);
                    const textAfterCursor = currentText.substring(insertionCursorPosition);
                    noteEditorElement.value = textBeforeCursor + imageMarkdownText + textAfterCursor;

                    notePreviewElement.innerHTML = marked.parse(noteEditorElement.value);
                    const updatedCursorPosition = insertionCursorPosition + imageMarkdownText.length;
                    noteEditorElement.setSelectionRange(updatedCursorPosition, updatedCursorPosition);
                    autoResize(noteEditorElement);
                    setTimeout(() => noteEditorElement?.focus(), 0);
                };
                fileReaderObject.onerror = function() {
                    console.error("FileReader error reading pasted image.");
                }
                fileReaderObject.readAsDataURL(pastedFile);
            }
        }
    }

    // Initialize first note
    const initialNoteElement = createNote("");
    blockContainer.prepend(initialNoteElement);
    setActiveTopNote(initialNoteElement);

</script>
</body>
</html>